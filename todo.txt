= test-drive rwlock

= expectAction() inside action methods

= put TestThread methods in breadth-first order

= have TestThread throw IllegalStateException instead  of assertions in a few places

= review synchronized usage in TestThread

= making coding style consistent

= rename *Tests to *Test

= delete ThreadTests, but move isBlocked somewhere reasonable

= in ReadWriteLock, decrement correctly when waiting writer is interrupted

= get rid of now-unused timed-wait stuff in Semaphore

= get rid of redundent lock object in Semaphore

= get rid of the try/catch to deal with different ordering in
  SemaphoreTest#testThreeThreadsOneResource, since we're presuming that the
  order is deterministic until we learn otherwise

= remove unused imports

= move examples to subpackage

= come up with a good way to stop TestThread

= discuss code review techniques: notify, synchronized, etc.

= copy BoundedBuffer to BrokenBoundedBuffer

x make checkpoint optional (so don't always have to "perform" it)

= introduce FixedBoundedBuffer

= eliminate duplication between BrokenBoundedBufferTest and FixedBoundedBufferTest

= test-drive fixing the notify/notifyAll problems in examples using
  "checkpoint" method
  <http://c2.com/cgi/wiki?ExtremeProgrammingChallengeFourteenTheBug>

= try putting TestThreads in a ThreadGroup so that letRun can let them all run

- discuss blocking with unrelated threads on [[I object

- review/fix other notify() call in BoundedBuffer

- add jar and javadoc Ant targets

- include pre-built jar and javadoc in distribution

- link to javadoc from home page

- if exception is thrown from action, rethrow it from assertComplete
  (instead of calling printStackTrace)

- if InterruptedException is thrown from action, allow that fact to
  be asserted

= include thread and action name in assertions

- consider how to test timed-wait stuff in Semaphore

.......................
    public boolean isBlocked(Thread thread)
    {
        ThreadMBean threads = ManagementFactory.getThreadMBean();
        assertTrue(threads.isThreadContentionMonitoringEnabled());
        while (true)
        {
            Thread.yield();
            ThreadInfo info = threads.getThreadInfo(thread.getId());
            if (info == null)
            {
                return false;
            }
            ThreadState state = info.getThreadState();
            if (state == ThreadState.NEW || state == ThreadState.RUNNING)
            {
                continue;
            }
            else if (state == ThreadState.BLOCKED
                    || state == ThreadState.WAITING
                    || state == ThreadState.TIMED_WAITING)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
